#
# Take a new OpenTLC cluster and prepare it for a REDSORD demo.
#
# It will:
#   - Strip out the LimitRange from the default project template.
#   - Create the argocd namespace
#   - Install the community argocd operator
#   - Create a new ClusterRoleBinding for the argocd-application-server SA
#     that gives it cluster-admin (naughty, naughty).
#   - Create a new ArgoCD resource to start the server.
#
- hosts: localhost
  connection: local
  gather_facts: false
  module_defaults:
    community.kubernetes.k8s_auth:
      host: "{{ lookup('env', 'OPENSHIFT_API_URL') }}"
      validate_certs: "{{ not (lookup('env', 'OPENSHIFT_API_INSECURE_CERTS')) | bool }}"

    community.kubernetes.k8s_info:
      host: "{{ lookup('env', 'OPENSHIFT_API_URL') }}"
      validate_certs: "{{ not (lookup('env', 'OPENSHIFT_API_INSECURE_CERTS') | bool) }}"

    community.kubernetes.k8s:
      host: "{{ lookup('env', 'OPENSHIFT_API_URL') }}"
      validate_certs: "{{ not (lookup('env', 'OPENSHIFT_API_INSECURE_CERTS') | bool) }}"

  tasks:
    - name: remove LimitRange from default project template
      k8s:
        merge_type: 'merge'
        definition:
          apiVersion: template.openshift.io/v1
          kind: Template
          metadata:
            name: project-request
            namespace: openshift-config
          objects:
          - apiVersion: networking.k8s.io/v1
            kind: NetworkPolicy
            metadata:
              name: allow-from-all-namespaces
            spec:
              ingress:
              - from:
                - namespaceSelector: {}
              podSelector: {}
          - apiVersion: networking.k8s.io/v1
            kind: NetworkPolicy
            metadata:
              name: allow-from-ingress-namespace
            spec:
              ingress:
              - from:
                - namespaceSelector:
                    matchLabels:
                      network-policy: global
              podSelector: null
          - apiVersion: project.openshift.io/v1
            kind: Project
            metadata:
              annotations:
                openshift.io/description: ${PROJECT_DESCRIPTION}
                openshift.io/display-name: ${PROJECT_DISPLAYNAME}
                openshift.io/requester: ${PROJECT_REQUESTING_USER}
              name: ${PROJECT_NAME}
            spec: {}
            status: {}
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              annotations:
                openshift.io/description: Allows all pods in this namespace to pull images from this namespace.  It is auto-managed by a controller; remove subjects to disable.
              name: system:image-pullers
              namespace: ${PROJECT_NAME}
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: system:image-puller
            subjects:
            - apiGroup: rbac.authorization.k8s.io
              kind: Group
              name: system:serviceaccounts:${PROJECT_NAME}
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              annotations:
                openshift.io/description: Allows builds in this namespace to push images to this namespace.  It is auto-managed by a controller; remove subjects to disable.
              name: system:image-builders
              namespace: ${PROJECT_NAME}
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: system:image-builder
            subjects:
            - kind: ServiceAccount
              name: builder
              namespace: ${PROJECT_NAME}
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              annotations:
                openshift.io/description: Allows deploymentconfigs in this namespace to rollout pods in this namespace.  It is auto-managed by a controller; remove subjects to disable.
              name: system:deployers
              namespace: ${PROJECT_NAME}
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: system:deployer
            subjects:
            - kind: ServiceAccount
              name: deployer
              namespace: ${PROJECT_NAME}
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              name: admin
              namespace: ${PROJECT_NAME}
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: admin
            subjects:
            - apiGroup: rbac.authorization.k8s.io
              kind: User
              name: ${PROJECT_ADMIN_USER}
          parameters:
          - name: PROJECT_NAME
          - name: PROJECT_DISPLAYNAME
          - name: PROJECT_DESCRIPTION
          - name: PROJECT_ADMIN_USER
          - name: PROJECT_REQUESTING_USER

    - name: create argocd project
      k8s:
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: argocd
          spec: {}

    - name: create an OperatorGroup for argocd
      k8s:
        definition:
          apiVersion: operators.coreos.com/v1
          kind: OperatorGroup
          metadata:
            name: argocd-og
            namespace: argocd
          spec:
            targetNamespaces:
            - argocd

    - name: create subscription for community argocd operator
      k8s:
        definition:
          apiVersion: operators.coreos.com/v1alpha1
          kind: Subscription
          metadata:
            name: argocd-operator
            namespace: argocd
          spec:
            channel: alpha
            installPlanApproval: Automatic
            name: argocd-operator
            source: community-operators
            sourceNamespace: openshift-marketplace
            startingCsv: argocd-operator:v0.0.14

    - name: create cluster-admin CRB for argocd-application-server
      k8s:
        definition:
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: argocd-application-server-cluster-admin
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: cluster-admin
          subjects:
          - kind: ServiceAccount
            name: argocd-application-server
            namespace: argocd

    - name: create argocd
      k8s:
        definition:
          apiVersion: argoproj.io/v1alpha1
          kind: ArgoCD
          metadata:
            name: helms-deep
            namespace: argocd
          spec:
            server:
              route:
                enabled: true

    - name: wait for argocd to rollout
      k8s_info:
        api_version: argoproj.io/v1alpha1
        kind: ArgoCD
        name: helms-deep
        namespace: argocd
      register: argocd
      delay: 5
      retries: 30
      until:
        - argocd.resources | length > 0
        - argocd.resources[0].status is defined
        - "argocd.resources[0].status.phase == 'Available'"

    - name: get route for argocd
      k8s_info:
        api_version: route.openshift.io/v1
        kind: Route
        name: helms-deep-server
        namespace: argocd
      register: argocd_server_route

    - name: get argocd login secret
      k8s_info:
        api_version: v1
        kind: Secret
        name: helms-deep-cluster
        namespace: argocd
      register: argocd_auth_secret

    - name: get argocd login token
      uri:
        url: "https://{{ argocd_server_route.resources[0].spec.host }}/api/v1/session"
        method: POST
        body_format: json
        body:
          username: "admin"
          password: "{{ argocd_auth_secret.resources[0].data['admin.password'] | b64decode }}"
        validate_certs: false
      register: auth_token_raw

    - set_fact:
        auth_token: "{{ auth_token_raw.json.token }}"

    - name: create repository
      uri:
        url: "https://{{ argocd_server_route.resources[0].spec.host }}/api/v1/repositories"
        method: POST
        headers:
          Cookie: "argocd.token={{ auth_token }}"
        body_format: json
        body:
          name: "devsecops-state"
          repo: "git@github.com:adamgoossens/dod-devsecops-state.git"
          sshPrivateKey: "{{ lookup('file', lookup('env', 'SSH_PRIVATE_KEY_FILE')) }}"
        validate_certs: false
      register: create_repo
     
    - debug: var=create_repo
